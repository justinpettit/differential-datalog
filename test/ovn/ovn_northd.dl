import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import allocate

/* Meter_Band table */
for (mb in nb.Meter_Band) {
    sb.Out_Meter_Band(.uuid_name = uuid2str(mb._uuid),
                      .action = mb.action,
                      .rate = mb.rate,
                      .burst_size = mb.burst_size)
}

/* Meter table */
sb.Out_Meter(name, unit, str_bands) :-
    nb.Meter(_, name, unit, bands, _),
    var uuid_band = FlatMap(bands),
    var str_band = uuid2str(uuid_band),
    Aggregate((name, unit), str_bands = group2set(str_band)).

/* Datapath_Binding table */
sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-switch", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:network_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Router(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-router", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:router_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.OutProxy_Datapath_Binding(uuid_str, tunkey, external_ids) :-
    sb.Out_Datapath_Binding(uuid_str, _, external_ids),
    TunKeyAllocation(uuid_str, tunkey).



/* Port_Binding table

relation Out_Port_Binding (
    uuid_name: string,
    logical_port: string,
    __type: string,
    gateway_chassis: Set<string>,
    options: Map<string,string>,
    datapath: string,
    tunnel_key: integer,
    parent_port: Set<string>,
    tag: Set<integer>,
    chassis: Set<uuid>,
    mac: Set<string>,
    nat_addresses: Set<string>,
    external_ids: Map<string,string>
)
*/

relation LogicalPortSwitch(lport: uuid, lswitch: uuid)

LogicalPortSwitch(lport, lswitch) :-
    nb.Logical_Switch(._uuid = lswitch, .ports = ports),
    var lport = FlatMap(ports).

relation LogicalPortRouter(lport: uuid, lrouter: uuid)

LogicalPortRouter(lport, lrouter) :-
    nb.Logical_Router(._uuid = lrouter, .ports = ports),
    var lport = FlatMap(ports).


/* Case 1: Create a Port_Binding per logical switch port that is not of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = lsp.__type,
                    .gateway_chassis    = set_empty(),
                    .options            = lsp.options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = set_empty(),
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type != "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.


/* Case 2: Create a Port_Binding per logical switch port of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = nat_addresses,
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type == "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    },
    Some{var router_port} = map_get(lsp.options, "router-port"),
    nb.Logical_Router_Port(.name = router_port, ._uuid = lport_uuid),
    LogicalPortRouter(lport_uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options, var nat_addresses) = {
        match (map_get(lroptions, "chassis")) {
            None -> {
                ("patch", map_empty(): Map<string, string>, set_empty(): Set<string>/*TODO*/)
            },
            Some{chassis} -> {
                var options: Map<string, string> = map_empty();
                map_insert(options, "peer", router_port);
                map_insert(options, "l3gateway-chassis", chassis);
                ("l3gateway", options, set_empty(): Set<string>/*TODO*/)
            }
        }
    }.

sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lrp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = map_union(options1, options2),
                    .datapath           = uuid2str(lrouter_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(), // always empty for router ports
                    .mac                = set_singleton(string_join(set2vec(set_insert_imm(lrp.networks, lrp.mac)), " ")),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    nb.Logical_Router_Port[lrp],
    var uuid_name = uuid2str(lrp._uuid),
    LogicalPortRouter(lrp._uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options1) = match (map_get(lroptions, "chassis")) {
        /* TODO: derived ports */
        None -> ("patch", map_empty(): Map<string, string>),
        Some{lrchassis} -> ("l3gateway", map_singleton("l3gateway-chassis", lrchassis))
    },
    var options2 = match (map_get(lrp.options, "peer")) {
        None -> map_empty(): Map<string, string>,
        Some{peer} -> map_singleton("peer", peer)
    },
    var eids = {
        var eids = lrp.external_ids;
        match (map_get(lrp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.

sb.OutProxy_Port_Binding(.uuid_name          = pbinding.uuid_name,
                         .logical_port       = pbinding.logical_port,
                         .__type             = pbinding.__type,
                         .gateway_chassis    = pbinding.gateway_chassis,
                         .options            = options,
                         .datapath           = pbinding.datapath,
                         .tunnel_key         = tunkey,
                         .parent_port        = pbinding.parent_port,
                         .tag                = pbinding.tag,
                         .mac                = pbinding.mac,
                         .nat_addresses      = pbinding.nat_addresses,
                         .external_ids       = pbinding.external_ids) :-
    sb.Swizzled_Port_Binding[pbinding],
    PortTunKeyAllocation(pbinding.uuid_name, tunkey),
    QueueIDAllocation(pbinding.uuid_name, qid),
    var options = match (qid) {
        None -> pbinding.options,
        Some{id} -> map_insert_imm(pbinding.options, "qdisc_queue_id", $"${id}")
    }.

/*
 * SB_Global (pull latest OVS schema; copy nb_cfg and options from NB)
 */

/*
 * Address_Set: copy from NB + additional records generated from NB Port_Group (two records for each
 * Port_Group for IPv4 and IPv6 addresses)
 */

/*
 * Port_Group: copy from NB, but replace UUIDs with logical port names
 */

/*
 * Multicast_Group: two rows per logical switch, one for flooding and one for packets with unknown
 * destinations.
 */

/*
 * MAC binding: records inserted by hypervisors; northd removes records for deleted logical ports
 */

/*
 * DHCP options: fixed table
 */

/*
 * DHCPv6 options: fixed table
 */

/*
 * DNS: copied from NB + datapaths column pointer to LS datapaths that use the record
 */

/*
 * RBAC_Role: fixed
 */

/*
 * RBAC_Permission: fixed
 */

/*
 * Gateway chassis: row per NB router ports that represent GW chassis
 */

/*
 * Logical_Flow
   relation Out_Logical_Flow (
        logical_datapath: string,
        pipeline: string,
        table_id: integer,
        priority: integer,
        __match: string,
        actions: string,
        external_ids: Map<string,string>

#define PIPELINE_STAGES                                                   \
    PIPELINE_STAGE(SWITCH, IN,  PORT_SEC_L2,    0, "ls_in_port_sec_l2")   \
    PIPELINE_STAGE(SWITCH, IN,  PORT_SEC_IP,    1, "ls_in_port_sec_ip")   \
    PIPELINE_STAGE(SWITCH, IN,  PORT_SEC_ND,    2, "ls_in_port_sec_nd")   \
    PIPELINE_STAGE(SWITCH, IN,  PRE_ACL,        3, "ls_in_pre_acl")       \
    PIPELINE_STAGE(SWITCH, IN,  PRE_LB,         4, "ls_in_pre_lb")        \
    PIPELINE_STAGE(SWITCH, IN,  PRE_STATEFUL,   5, "ls_in_pre_stateful")  \
    PIPELINE_STAGE(SWITCH, IN,  ACL,            6, "ls_in_acl")           \
    PIPELINE_STAGE(SWITCH, IN,  QOS_MARK,       7, "ls_in_qos_mark")      \
    PIPELINE_STAGE(SWITCH, IN,  QOS_METER,      8, "ls_in_qos_meter")     \
    PIPELINE_STAGE(SWITCH, IN,  LB,             9, "ls_in_lb")            \
    PIPELINE_STAGE(SWITCH, IN,  STATEFUL,      10, "ls_in_stateful")      \
    PIPELINE_STAGE(SWITCH, IN,  ARP_ND_RSP,    11, "ls_in_arp_rsp")       \
    PIPELINE_STAGE(SWITCH, IN,  DHCP_OPTIONS,  12, "ls_in_dhcp_options")  \
    PIPELINE_STAGE(SWITCH, IN,  DHCP_RESPONSE, 13, "ls_in_dhcp_response") \
    PIPELINE_STAGE(SWITCH, IN,  DNS_LOOKUP,    14, "ls_in_dns_lookup")    \
    PIPELINE_STAGE(SWITCH, IN,  DNS_RESPONSE,  15, "ls_in_dns_response")  \
    PIPELINE_STAGE(SWITCH, IN,  L2_LKUP,       16, "ls_in_l2_lkup")       \
                                                                          \
    PIPELINE_STAGE(SWITCH, OUT, PRE_LB,       0, "ls_out_pre_lb")         \
    PIPELINE_STAGE(SWITCH, OUT, PRE_ACL,      1, "ls_out_pre_acl")        \
    PIPELINE_STAGE(SWITCH, OUT, PRE_STATEFUL, 2, "ls_out_pre_stateful")   \
    PIPELINE_STAGE(SWITCH, OUT, LB,           3, "ls_out_lb")             \
    PIPELINE_STAGE(SWITCH, OUT, ACL,          4, "ls_out_acl")            \
    PIPELINE_STAGE(SWITCH, OUT, QOS_MARK,     5, "ls_out_qos_mark")       \
    PIPELINE_STAGE(SWITCH, OUT, QOS_METER,    6, "ls_out_qos_meter")      \
    PIPELINE_STAGE(SWITCH, OUT, STATEFUL,     7, "ls_out_stateful")       \
    PIPELINE_STAGE(SWITCH, OUT, PORT_SEC_IP,  8, "ls_out_port_sec_ip")    \
    PIPELINE_STAGE(SWITCH, OUT, PORT_SEC_L2,  9, "ls_out_port_sec_l2")    \
                                                                      \
    PIPELINE_STAGE(ROUTER, IN,  ADMISSION,      0, "lr_in_admission")    \
    PIPELINE_STAGE(ROUTER, IN,  IP_INPUT,       1, "lr_in_ip_input")     \
    PIPELINE_STAGE(ROUTER, IN,  DEFRAG,         2, "lr_in_defrag")       \
    PIPELINE_STAGE(ROUTER, IN,  UNSNAT,         3, "lr_in_unsnat")       \
    PIPELINE_STAGE(ROUTER, IN,  DNAT,           4, "lr_in_dnat")         \
    PIPELINE_STAGE(ROUTER, IN,  ND_RA_OPTIONS,  5, "lr_in_nd_ra_options") \
    PIPELINE_STAGE(ROUTER, IN,  ND_RA_RESPONSE, 6, "lr_in_nd_ra_response") \
    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING,     7, "lr_in_ip_routing")   \
    PIPELINE_STAGE(ROUTER, IN,  ARP_RESOLVE,    8, "lr_in_arp_resolve")  \
    PIPELINE_STAGE(ROUTER, IN,  GW_REDIRECT,    9, "lr_in_gw_redirect")  \
    PIPELINE_STAGE(ROUTER, IN,  ARP_REQUEST,    10, "lr_in_arp_request")  \
                                                                      \
    PIPELINE_STAGE(ROUTER, OUT, UNDNAT,    0, "lr_out_undnat")        \
    PIPELINE_STAGE(ROUTER, OUT, SNAT,      1, "lr_out_snat")          \
    PIPELINE_STAGE(ROUTER, OUT, EGR_LOOP,  2, "lr_out_egr_loop")      \
    PIPELINE_STAGE(ROUTER, OUT, DELIVERY,  3, "lr_out_delivery")

#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)   \
    S_##DP_TYPE##_##PIPELINE##_##STAGE                          \
        = OVN_STAGE_BUILD(DP_##DP_TYPE, P_##PIPELINE, TABLE),
    PIPELINE_STAGES
#undef PIPELINE_STAGE
};

    )
 */



///* Logical switch ingress table 0: admission control framework (priority 100) */
//for (ls in Logical_Switch) {
//    var lsname = uuid2str(ls.uuid) in
//    /* Logical VLANs not supported */
//    Out_Logical_Flow(.logical_datapath = lsname,
//                     .pipeline         = "ingress",
//                     .table_id         = switch_stage(IN, "ls_in_port_sec_l2"),
//                     .priority         = 100,
//                     .__match          = "vlan.present",
//                     .actions          = "drop;",
//                     .external_ids     = map_empty() /*TODO: check*/);
//
//    /* Broadcast/multicast source address is invalid */
//    Out_Logical_Flow(.logical_datapath = lsname,
//                     .pipeline         = "ingress",
//                     .table_id         = switch_stage(IN, "ls_in_port_sec_l2"),
//                     .priority         = 100,
//                     .__match          = "eth.src[40]",
//                     .actions          = "drop;",
//                     .external_ids     = map_empty() /*TODO: check*/);
//
//    /* Port security flows have priority 50 (see below) and will continue to the next table
//       if packet source is acceptable. */
//}
//
//function is_enabled(s: Set<bool>): bool = {
//    set_nth(s, 0) == Some{true} or set_nth(s,0) == None
//}
//
///* Logical switch ingress table 0: ingress port security - L2 (priority 50)
//                  ingress table 1: ingress port security - IP (priority 90 and 80)
//                  ingress table 2: ingress port security - ND (priority 90 and 80) */
//for (ls in Logical_Switch) {
//    for (lsp in Logical_Switch_Port if lsp.lswitch == ls) {
//        for (pbinding in Out_Port_Binding if pbinding.logical_port == lsp.name) {
//            /* drop packets from disabled logical ports (since logical flow tables are default drop) */
//            if (is_enabled(lsp.enabled)) {
//                var qid = match (map_get(pbinding.options, "qdisc_queue_id")) {
//                        None => "",
//                        Some{id} => $"set_queue(${id}); "
//                    },
//                    l2_ps = if (set_is_empty(lsp.port_security)) {
//                        ""
//                    } else {
//                        $" && eth.src == {${string_join(port_security_eth_addresses(lsp.port_security), " ")}}"
//                    }
//                in
//                /* Logical VLANs not supported */
//                Out_Logical_Flow(.logical_datapath = lsname,
//                                 .pipeline         = "ingress",
//                                 .table_id         = switch_stage(IN, "ls_in_port_sec_l2"),
//                                 .priority         = 50,
//                                 .__match          = $"inport == ${lsp.name}${l2_ps}",
//                                 .actions          = $"${qid}next;",
//                                 .external_ids     = map_empty() /*TODO: check*/);
//            }
//        }
//    }
//}


/*
 * Datapath tunnel key allocation:
 *
 * Allocates a globally unique tunnel id in the range 1...2**24-1 for
 * each Logical_Switch and Logical_Router.
 */

// all tunnel keys already in use in the Realized table
relation AllocatedTunKeys(keys: Set<integer>)

AllocatedTunKeys(keys) :-
    sb.Datapath_Binding(.tunnel_key = tunkey),
    Aggregate((), keys = group2set(tunkey)).

// Datapath_Binding's not yet in the Realized table
relation NotYetAllocatedTunKeys(datapaths: Vec<string>)

NotYetAllocatedTunKeys(datapaths) :-
    sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                .id = Right{_}),
    datapath != "",
    Aggregate((), datapaths = group2vec(datapath)).

// Perform the allocation
relation TunKeyAllocation(datapath: string, tunkey: integer)

// transfer existing allocations from the realized table
TunKeyAllocation(datapath, tunkey) :-
     sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                 .id = Left{uuid}),
     sb.Datapath_Binding(._uuid = uuid,
                         .tunnel_key = tunkey).

// Case 1: AllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    AllocatedTunKeys(allocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

// Case 2: AllocatedTunKeys relation is empty
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    not AllocatedTunKeys(_),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

/*
 * Port id allocation:
 *
 * Port IDs in a per-datapath space in the range 1...2**15-1
 */

// all tunnel keys already in use in the Realized table
relation AllocatedPortTunKeys(datapath: string, keys: Set<integer>)

AllocatedPortTunKeys(datapath_name, keys) :-
    sb.Port_Binding(.datapath = datapath_uuid, .tunnel_key = tunkey),
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{datapath_uuid}),
    Aggregate((datapath_name), keys = group2set(tunkey)).

// Port_Binding's not yet in the Realized table
relation NotYetAllocatedPortTunKeys(datapath: string, all_logical_ids: Vec<string>)

NotYetAllocatedPortTunKeys(datapath, all_names) :-
    sb.Out_Port_Binding(.uuid_name = uuid_name, .datapath = datapath),
    sb.UUIDMap_Port_Binding(.uuid_name = uuid_name,
                            .id = Right{_}),
    Aggregate((datapath), all_names = group2vec(uuid_name)).

// Perform the allocation
relation PortTunKeyAllocation(port: string, tunkey: integer)

// transfer existing allocations from the realized table
PortTunKeyAllocation(port, tunkey) :-
     sb.UUIDMap_Port_Binding(.uuid_name = port,
                             .id = Left{uuid}),
     sb.Port_Binding(._uuid = uuid,
                     .tunnel_key = tunkey).

// Case 1: AllocatedPortTunKeys(datapath) is not empty (i.e., contains
// a single record that stores a set of allocated keys)
PortTunKeyAllocation(port, tunkey) :-
    AllocatedPortTunKeys(datapath, allocated),
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

// Case 2: PortAllocatedTunKeys(datapath) relation is empty
PortTunKeyAllocation(port, tunkey) :-
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    not AllocatedPortTunKeys(datapath, _),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

/*
 * Queue ID allocation
 *
 * Queue IDs on a chassis, for routers that have QoS enabled, in a per-chassis
 * space in the range 1...0xf000.  It looks to me like there'd only be a small
 * number of these per chassis, and probably a small number overall, in case it
 * matters.
 *
 * Queue ID may also need to be deallocated if port loses QoS attributes
 *
 * This logic only applies to ports with chassis attribute, i.e., they must be
 * in sb.Port_Binding.
 */

function port_has_qos_params(opts: Map<string, string>): bool = {
    is_some(map_get(opts, "qos_max_rate")) or
    is_some(map_get(opts, "qos_burst"))
}


// ports in Out_Port_Binding that require queue ID on chassis
relation PortRequiresQID(port: string, chassis: uuid)

PortRequiresQID(pb.uuid_name, chassis) :-
    sb.Out_Port_Binding[pb],
    port_has_qos_params(pb.options),
    sb.UUIDMap_Port_Binding(pb.uuid_name, Left{uuid}),
    sb.Port_Binding(._uuid = uuid, .chassis = chassis_set),
    Some{var chassis} = set_nth(chassis_set, 0).

relation AggPortRequiresQID(chassis: uuid, ports: Vec<string>)

AggPortRequiresQID(chassis, ports) :-
    PortRequiresQID(port, chassis),
    Aggregate((chassis), ports = group2vec(port)).

relation AllocatedQIDs(chassis: uuid, allocated_ids: Map<string, integer>)

AllocatedQIDs(chassis, allocated_ids) :-
    sb.Port_Binding[pb],
    Some{var chassis} = set_nth(pb.chassis, 0),
    Some{var qid_str} = map_get(pb.options, "qdisc_queue_id"),
    Some{var qid: bit<64>} = parse_dec_u64(qid_str),
    sb.UUIDMap_Port_Binding(port, Left{pb._uuid}),
    Aggregate((chassis), allocated_ids = group2map((port, qid))).

// allocate queueue IDs to ports
relation QueueIDAllocation(port: string, qids: Option<integer>)

// None for ports that do not require a queue
QueueIDAllocation(port, None) :-
    sb.Out_Port_Binding(.uuid_name = port),
    not PortRequiresQID(port, _).

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    AllocatedQIDs(chassis, allocated_ids),
    var allocations = FlatMap(adjust_allocation_u64(allocated_ids, ports, 64'hf000)),
    (var port, var qid) = allocations.

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    not AllocatedQIDs(chassis, _),
    var allocations = FlatMap(adjust_allocation_u64(map_empty(): Map<string, integer>, ports, 64'hf000)),
    (var port, var qid) = allocations.
