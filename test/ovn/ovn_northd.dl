import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import allocate

/* Meter_Band table */
for (mb in nb.Meter_Band) {
    sb.Out_Meter_Band(.uuid_name = uuid2str(mb._uuid),
                      .action = mb.action,
                      .rate = mb.rate,
                      .burst_size = mb.burst_size)
}

/* Meter table */
sb.Out_Meter(name, unit, str_bands) :-
    nb.Meter(_, name, unit, bands, _),
    var uuid_band = FlatMap(bands),
    var str_band = uuid2str(uuid_band),
    Aggregate((name, unit), str_bands = group2set(str_band)).

/* Datapath_Binding table */
sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-switch", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:network_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Router(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-router", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:router_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.OutProxy_Datapath_Binding(uuid_str, tunkey, external_ids) :-
    sb.Out_Datapath_Binding(uuid_str, _, external_ids),
    TunKeyAllocation(uuid_str, tunkey).



/* Port_Binding table

relation Out_Port_Binding (
    uuid_name: string,
    logical_port: string,
    __type: string,
    gateway_chassis: Set<string>,
    options: Map<string,string>,
    datapath: string,
    tunnel_key: integer,
    parent_port: Set<string>,
    tag: Set<integer>,
    chassis: Set<uuid>,
    mac: Set<string>,
    nat_addresses: Set<string>,
    external_ids: Map<string,string>
)
*/

relation LogicalPortSwitch(lport: uuid, lswitch: uuid)

LogicalPortSwitch(lport, lswitch) :-
    nb.Logical_Switch(._uuid = lswitch, .ports = ports),
    var lport = FlatMap(ports).

relation LogicalPortRouter(lport: uuid, lrouter: uuid)

LogicalPortRouter(lport, lrouter) :-
    nb.Logical_Router(._uuid = lrouter, .ports = ports),
    var lport = FlatMap(ports).


/* Case 1: Create a Port_Binding per logical switch port that is not of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = lsp.__type,
                    .gateway_chassis    = set_empty(),
                    .options            = lsp.options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .chassis            = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = set_empty(),
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type != "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.


sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .chassis            = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = nat_addresses,
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type == "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    },
    Some{var router_port} = map_get(lsp.options, "router-port"),
    nb.Logical_Router_Port(.name = router_port, ._uuid = lport_uuid),
    LogicalPortRouter(lport_uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options, var nat_addresses) = {
        match (map_get(lroptions, "chassis")) {
            None -> {
                ("patch", map_empty(): Map<string, string>, set_empty(): Set<string>/*TODO*/)
            },
            Some{chassis} -> {
                var options: Map<string, string> = map_empty();
                map_insert(options, "peer", router_port);
                map_insert(options, "l3gateway-chassis", chassis);
                ("l3gateway", options, set_empty(): Set<string>/*TODO*/)
            }
        }
    }.

/*
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lrp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = map_union(options1, options2),
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(), // always empty for router ports
                    .chassis            = set_empty(),
                    .mac                = punctuate(set_insert(lrp.networks, lrp.mac), " "),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    nb.Logical_Router_Port[lrp],
    var uuid_name = uuid2str(lrp._uuid),
    LogicalPortRouter(lrp._uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options1) = match (map_get(lroptions, "chassis")) {
        None -> ("patch", map_empty()),
        Some{lrchassis} -> ("l3gateway", map_singleton("l3gateway-chassis", lrchassis))
    },
    var options2 = match (map_get(lrp.options, "peer")) {
        None -> map_empty(),
        Some{peer} -> map_singleton("peer", peer)
    },

    var eids = {
        var eids = lsp.external_ids;
        match map_get(lsp.external_ids, "neutron:port_name") {
            None -> {},
            Some(name) -> map_insert(eids, "name", name)
        };
        eids
    }.
*/

/*
 * Datapath tunnel key allocation:
 *
 * Allocates a globally unique tunnel id in the range 1...2**24-1 for
 * each Logical_Switch and Logical_Router.
 */

// all tunnel keys already in use in the Realized table
relation AllocatedTunKeys(keys: Set<integer>)

AllocatedTunKeys(keys) :-
    sb.Datapath_Binding(.tunnel_key = tunkey),
    Aggregate((), keys = group2set(tunkey)).

// Datapath_Binding's not yet in the Realized table
relation NotYetAllocatedTunKeys(datapaths: Vec<string>)

NotYetAllocatedTunKeys(datapaths) :-
    sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                .id = Right{_}),
    datapath != "",
    Aggregate((), datapaths = group2vec(datapath)).

// Perform the allocation
relation TunKeyAllocation(datapath: string, tunkey: integer)

// transfer existing allocations from the realized table
TunKeyAllocation(datapath, tunkey) :-
     sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                 .id = Left{uuid}),
     sb.Datapath_Binding(._uuid = uuid,
                         .tunnel_key = tunkey).

// Case 1: AllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    AllocatedTunKeys(allocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

// Case 2: AllocatedTunKeys relation is empty
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    not AllocatedTunKeys(_),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

/*
 * Port id allocation:
 *
 * Port IDs in a per-datapath space in the range 1...2**15-1
 */

// all tunnel keys already in use in the Realized table
relation AllocatedPortTunKeys(datapath: string, keys: Set<integer>)

AllocatedPortTunKeys(datapath_name, keys) :-
    sb.Port_Binding(.datapath = datapath_uuid, .tunnel_key = tunkey),
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{datapath_uuid}),
    Aggregate((datapath_name), keys = group2set(tunkey)).

// Port_Binding's not yet in the Realized table
relation NotYetAllocatedPortTunKeys(datapath: string, all_logical_ids: Vec<string>)

NotYetAllocatedPortTunKeys(datapath, all_names) :-
    sb.Out_Port_Binding(.uuid_name = uuid_name, .datapath = datapath),
    sb.UUIDMap_Port_Binding(.uuid_name = uuid_name,
                            .id = Right{_}),
    Aggregate((datapath), all_names = group2vec(uuid_name)).

// Perform the allocation
relation PortTunKeyAllocation(port: string, tunkey: integer)

// transfer existing allocations from the realized table
PortTunKeyAllocation(port, tunkey) :-
     sb.UUIDMap_Port_Binding(.uuid_name = port,
                             .id = Left{uuid}),
     sb.Port_Binding(._uuid = uuid,
                     .tunnel_key = tunkey).

// Case 1: AllocatedPortTunKeys(datapath) is not empty (i.e., contains
// a single record that stores a set of allocated keys)
PortTunKeyAllocation(port, tunkey) :-
    AllocatedPortTunKeys(datapath, allocated),
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

// Case 2: PortAllocatedTunKeys(datapath) relation is empty
TunKeyAllocation(port, tunkey) :-
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    not AllocatedPortTunKeys(datapath, _),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

/*
 * Queue ID allocation
 *
 * Queue IDs on a chassis, for routers that have QoS enabled, in a per-chassis
 * space in the range 1...0xf000.  It looks to me like there'd only be a small
 * number of these per chassis, and probably a small number overall, in case it
 * matters.
 *
 * Queue ID may also need to be deallocated if port loses QoS attributes
 *
 * This logic only applies to ports with chassis attribute, i.e., they must be
 * in sb.Port_Binding.
 */

function port_has_qos_params(opts: Map<string, string>): bool = {
    is_some(map_get(opts, "qos_max_rate")) or
    is_some(map_get(opts, "qos_burst"))
}


// ports in Out_Port_Binding that require queue ID on chassis
relation PortRequiresQID(port: string, chassis: uuid)

PortRequiresQID(pb.uuid_name, chassis) :-
    sb.Out_Port_Binding[pb],
    port_has_qos_params(pb.options),
    sb.UUIDMap_Port_Binding(pb.uuid_name, Left{uuid}),
    sb.Port_Binding(._uuid = uuid, .chassis = chassis_set),
    Some{var chassis} = set_nth(chassis_set, 0).

relation AggPortRequiresQID(chassis: uuid, ports: Vec<string>)

AggPortRequiresQID(chassis, ports) :-
    PortRequiresQID(port, chassis),
    Aggregate((chassis), ports = group2vec(port)).

relation AllocatedQIDs(chassis: uuid, allocated_ids: Map<string, integer>)

AllocatedQIDs(chassis, allocated_ids) :-
    sb.Port_Binding[pb],
    Some{var chassis} = set_nth(pb.chassis, 0),
    Some{var qid_str} = map_get(pb.options, "qdisc_queue_id"),
    Some{var qid: bit<64>} = parse_dec_u64(qid_str),
    sb.UUIDMap_Port_Binding(port, Left{pb._uuid}),
    Aggregate((chassis), allocated_ids = group2map((port, qid))).

// allocate queueue IDs to ports
relation QueueIDAllocation(port: string, qids: Option<integer>)

// None for ports that do not require a queue
QueueIDAllocation(port, None) :-
    sb.Out_Port_Binding(.uuid_name = port),
    not PortRequiresQID(port, _).

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    AllocatedQIDs(chassis, allocated_ids),
    var allocations = FlatMap(adjust_allocation_u64(allocated_ids, ports, 64'hf000)),
    (var port, var qid) = allocations.

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    not AllocatedQIDs(chassis, _),
    var allocations = FlatMap(adjust_allocation_u64(map_empty(): Map<string, integer>, ports, 64'hf000)),
    (var port, var qid) = allocations.
