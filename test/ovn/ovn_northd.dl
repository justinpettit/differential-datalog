import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import allocate

/* Meter_Band table */
for (mb in nb.Meter_Band) {
    sb.Meter_Band(.uuid_name = uuid2str(mb._uuid),
                  .action = mb.action,
                  .rate = mb.rate,
                  .burst_size = mb.burst_size)
}


/* Meter table */
sb.Meter(name, unit, str_bands) :-
    nb.Meter(_, name, unit, bands, _),
    var uuid_band = FlatMap(bands),
    var str_band = uuid2str(uuid_band),
    Aggregate((name, unit), str_bands = group2set(str_band)).


/* Datapath_Binding table */
sb.Datapath_Binding(uuid_str, tunkey, external_ids) :-
    nb.Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    TunKeyAllocation(uuid_str, tunkey),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-switch", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:network-name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

/* tunnel key allocation */
output relation AllocatedTunKeys(logical_id: string, tunkey: integer)

// compute a set of already allocated keys from the Realized_Datapath_Binding table.
AllocatedTunKeys(ls_id, tunkey) :-
    sb.Realized_Datapath_Binding(.tunnel_key = tunkey,
                                 .external_ids = eids),
    Some{var ls_id} = map_get(eids, "logical-switch").

AllocatedTunKeys(lr_id, tunkey) :-
    sb.Realized_Datapath_Binding(.tunnel_key = tunkey,
                                 .external_ids = eids),
    Some{var lr_id} = map_get(eids, "logical-router").

output relation AggAllocatedTunKeys(allkeys: Set<integer>)

AggAllocatedTunKeys(allkeys) :-
    AllocatedTunKeys(_, tunkey),
    Aggregate((), allkeys = group2set(tunkey)).

// compute a vector of logical switch and logical router ids that
// have not been allocated keys yet

output relation NotYetAllocatedTunKeys(logical_id: string)

NotYetAllocatedTunKeys(ls_id) :-
    nb.Logical_Switch(._uuid = uuid),
    var ls_id = uuid2str(uuid),
    not AllocatedTunKeys(ls_id, _).

NotYetAllocatedTunKeys(lr_id) :-
    nb.Logical_Router(._uuid = uuid),
    var lr_id = uuid2str(uuid),
    not AllocatedTunKeys(lr_id, _).

output relation AggNotYetAllocatedTunKeys(all_logical_ids: Vec<string>)

AggNotYetAllocatedTunKeys(all_logical_ids) :-
    NotYetAllocatedTunKeys(lid),
    Aggregate((), all_logical_ids = group2vec(lid)).

// Perform the allocation
output relation TunKeyAllocation(logical_id: string, tunkey: integer)

// transfer existing allocations as is
TunKeyAllocation(lid, tunkey) :- AllocatedTunKeys(lid, tunkey).

// Case 1: AggAllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(lid, tunkey) :-
    AggAllocatedTunKeys(allocated),
    AggNotYetAllocatedTunKeys(unallocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hffff)),
    (var lid, var tunkey) = allocation.

// Case 2: AggAllocatedTunKeys relation is empty 
TunKeyAllocation(lid, tunkey) :-
    AggNotYetAllocatedTunKeys(unallocated),
    not AggAllocatedTunKeys(_),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hffff)),
    (var lid, var tunkey) = allocation.
